<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lucas Possatti</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://possatti.com.br/"/>
  <updated>2016-06-24T22:25:13.011Z</updated>
  <id>http://possatti.com.br/</id>
  
  <author>
    <name>Lucas Possatti</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ZettaJS</title>
    <link href="http://possatti.com.br/zettajs/"/>
    <id>http://possatti.com.br/zettajs/</id>
    <published>2015-03-31T04:11:36.000Z</published>
    <updated>2016-06-24T22:25:13.011Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;/images/zetta-logo.svg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Recentemente fiz um trabalho, na faculdade, sobre Internet das Coisas. Para esse trabalho eu tive de escrever um documento explicando sobre o assunto, e também o Zetta, que é uma plataforma para a Internet das Coisas. Além de desenvolver uma pequena aplicação que ilustrasse o tema. Então resolvi aproveitar para escrever um post sobre isso.&lt;/p&gt;
&lt;p&gt;A maior parte do que eu escrevi aqui, já era parte do meu trabalho. Mas eu aperfeiçoei alguns trechos para que algumas coisas ficassem mais claras, e o texto ficasse mais fácil de acompanhar.&lt;/p&gt;
&lt;p&gt;Eu irei começar falando sobre Internet das Coisas, de forma geral. E em seguida vou apresentar o Zetta, explicando para que serve e quais os seus pontos fortes e fracos. E no final, demonstrarei como colocar em execução uma aplicação do Zetta que eu desenvolvi.&lt;/p&gt;
&lt;h2 id=&quot;Introducao-a-Internet-das-Coisas&quot;&gt;&lt;a href=&quot;#Introducao-a-Internet-das-Coisas&quot; class=&quot;headerlink&quot; title=&quot;Introdução a Internet das Coisas&quot;&gt;&lt;/a&gt;Introdução a Internet das Coisas&lt;/h2&gt;&lt;p&gt;Um conceito que tem ganhado popularidade mais recentemente é o de &lt;a href=&quot;http://pt.wikipedia.org/wiki/Internet_das_Coisas&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Internet das Coisas&lt;/a&gt; (IoT, da sigla em inglês para “Internet of Things”). Esse conceito diz respeitos a objetos embarcados com dispositivos eletrônicos que podem se conectar através de uma rede e trocar informações entre si.&lt;/p&gt;
&lt;p&gt;Em Internet das Coisas, as “coisas” podem ser inúmeros tipos de dispositivos. Como equipamentos para monitoramento de batimentos cardíacos, luminosidade, velocidade, controladores, luzes, motores, veículos, e muitas outras coisas. Esses dispositivos tem a capacidade de coletar informações úteis e deixá-las fluir entre os outros dispositivos conectados, de forma autônoma. Tudo isso ficará mais claro ao executar a aplicação que desenvolvi.&lt;/p&gt;
&lt;p&gt;Para a aplicação do conceito de IoT, existem muitas plataformas e ferramentas. Como, por exemplo: Carriots, Xively, ZettaJS, ThingSpeak, Zatar e muitas outras. Mas aqui eu irei tratar apenas do Zetta.&lt;/p&gt;
&lt;h2 id=&quot;Sobre-o-Zetta&quot;&gt;&lt;a href=&quot;#Sobre-o-Zetta&quot; class=&quot;headerlink&quot; title=&quot;Sobre o Zetta&quot;&gt;&lt;/a&gt;Sobre o Zetta&lt;/h2&gt;&lt;p&gt;O Zetta é uma plataforma Open Source construída em cima do &lt;a href=&quot;https://nodejs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Node.js&lt;/a&gt; para criar servidores para aplicação de Internet das Coisas. Tendo seu primeiro commit feito no dia 18 de abril de 2014 em seu &lt;a href=&quot;https://github.com/zettajs/zetta/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;repositório oficial&lt;/a&gt;, o Zetta é uma plataforma relativamente nova, mas em constante desenvolvimento. Em sua &lt;a href=&quot;http://www.zettajs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;página principal&lt;/a&gt;, o Zetta declara utilizar uma API &lt;a href=&quot;http://pt.wikipedia.org/wiki/REST&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RESTful&lt;/a&gt;, &lt;a href=&quot;http://pt.wikipedia.org/wiki/WebSocket&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;WebSockets&lt;/a&gt; e &lt;a href=&quot;http://en.wikipedia.org/wiki/Reactive_programming&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Programação Reativa&lt;/a&gt; para conectar diversos dispositivos e proporcionar a criação de aplicações com intensa manipulação de dados, em tempo real.&lt;/p&gt;
&lt;p&gt;Como eu disse, o Zetta funciona em cima do Node.js (ou apenas Node), que é uma plataforma construída usando o V8, o Runtime de JavaScript do Google Chrome. O Node é útil para construir servidores web de forma rápida e fácil. E a linguagem JavaScript é utilizada para a programação.&lt;/p&gt;
&lt;p&gt;É possível executar um servidor Zetta em uma variedade de dispositivos, desde um PC qualquer, até um Arduíno, ou um Raspberry Pi. Assim o servidor pode se comunicar com diversos equipamentos conectados, como LEDs, sensores, telas e basicamente tudo com o qual o seu dispositivo puder se comunicar.&lt;/p&gt;
&lt;p&gt;Os desenvolvedores do Zetta, desenvolveram também o Zetta Browser. Que é uma aplicação web que pode ser utilizada para navegar através da API do Zetta. Assim, é possível apontá-lo para o endereço de um servidor Zetta e visualizar em tempo real todos os dados sendo coletados por aquele servidor. Bem como interagir com os dispositivos conectados a ele. Isso tudo em uma interface agradável e intuitiva. Contudo, o browser é um pouco instável, e as vezes apresenta algumas falhas. Mas, no geral, é uma ferramenta muito útil.&lt;/p&gt;
&lt;p&gt;O Zetta objetiva proporcionar uma maneira fácil e rápida de projetar aplicações para a Internet das Coisas. E proporcionando flexibilidade para controlar detalhes da aplicação.&lt;/p&gt;
&lt;p&gt;Porém um dos seus pontos fracos está na sua data de origem. Tendo surgido por volta do início de 2014, é de se esperar que não seja uma plataforma muito madura ainda. Ao navegar pelo site oficial, é fácil perceber pontos em que falta documentação, ou links que te levam a artigos completamente vazios. Ainda assim, a documentação no site é suficiente para iniciar o aprendizado. Porém, provavelmente chegará uma hora em que você sentirá falta de algumas informações, assim como eu senti.&lt;/p&gt;
&lt;p&gt;Ainda assim, o Zetta aparenta ser uma plataforma simples, robusta e estável. É possível utilizá-lo para realizar uma enormidade de projetos. E é uma ótima escolha para aqueles que estão iniciando com a Internet das Coisas, ou apenas querem matar a curiosidade.&lt;/p&gt;
&lt;p&gt;Outra vantagem para o Zetta é que, diferente de muitas plataformas com propósitos puramente comerciais, esse é um projeto Open Source (utilizando a licensa MIT) e sem fins comerciais (apesar de que você pode, sim, usá-lo para criar aplicações comerciais). E é um projeto que está em constante desenvolvimento.&lt;/p&gt;
&lt;p&gt;Mas a falta de uma grande empresa por trás do Zetta pode dificultar o seu uso em aplicações de larga escala. Por falta, por exemplo, de um suporte dedicado exclusivamente a atender seus clientes e a falta de garantia de funcionamento.&lt;/p&gt;
&lt;h2 id=&quot;Arquitetura-do-Zetta&quot;&gt;&lt;a href=&quot;#Arquitetura-do-Zetta&quot; class=&quot;headerlink&quot; title=&quot;Arquitetura do Zetta&quot;&gt;&lt;/a&gt;Arquitetura do Zetta&lt;/h2&gt;&lt;p&gt;A arquitetura de uma aplicação Zetta é basicamente a seguinte: existe um servidor Zetta central executando na nuvem (no Heroku, por exemplo), que está conectado a alguns Hubs (como um Raspberry Pi ou um Beaglebone) que rodam instâncias locais de um servidor Zetta. Esses Hubs por sua vez estão conectados a equipamentos eletrônicos e sensores (como exemplo, uma célula fotovoltaica e uma LED). Vejam isso ilustrado na &lt;strong&gt;INCRÍVEL&lt;/strong&gt; figura que eu fiz:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/arquitetura-do-zetta.jpg&quot; alt=&quot;Arquitetura do Zetta&quot;&gt;&lt;/p&gt;
&lt;p&gt;Dessa maneira, dados são obtidos dos diversos equipamentos e sensores e levados aos servidores dos hubs, que os encaminha ao servidor central. Isso funciona de forma geo-distribuída, então é possível que, por exemplo, um sensor fotovoltaico lá no japão faça com que uma lâmpada acenda aqui no Brasil.&lt;/p&gt;
&lt;p&gt;Essa lógica, de como as coisas acontecem e em função do quê, está toda nos servidores, podendo estar até mesmo distribuída entre os hubs e o servidor central.&lt;/p&gt;
&lt;h2 id=&quot;Demonstracao&quot;&gt;&lt;a href=&quot;#Demonstracao&quot; class=&quot;headerlink&quot; title=&quot;Demonstração&quot;&gt;&lt;/a&gt;Demonstração&lt;/h2&gt;&lt;p&gt;Para exemplificar o uso do Zetta, eu desenvolvi uma aplicação simples, baseada no &lt;a href=&quot;http://www.zettajs.org/projects/2014/10/13/Hello-World.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;tutorial para iniciantes&lt;/a&gt; disponível no site oficial. E adicionalmente, incrementei com uma funcionalidade a mais (controlar o player do meu PC), para exemplificar a criação de drivers.&lt;/p&gt;
&lt;p&gt;O exemplo disponibilizado no site ensina a criar um servidor local que irá servir para ilustrar uma aplicação que controla a luminosidade de um local. No exemplo é utilizado uma mock LED juntamente com uma mock photocell (célula voltaica), de maneira que quando a photocell detecta uma baixa luminosidade, a LED acende. E quando a photocell detecta elevada luminosidade, a LED apaga.&lt;/p&gt;
&lt;p&gt;Para aqueles que não estão familiarizados com o termo, “mock” nesse contexto, quer dizer que não há hardware sendo utilizado. Nem para a photocell, e nem para a LED. Os drivers utilizados procuram simular os comportamentos desses dispositivos. Por isso, é necessário apenas um computador para executar o projeto e ver tudo funcionando.&lt;/p&gt;
&lt;p&gt;Apesar do exemplo, parecer algo simples demais, este exemplo serve bem para ilustrar uma possível aplicação na vida real. Para fazer algo mais útil, você poderia colocar uma célula voltaica verdadeira no telhado da sua casa, e no lugar de uma LED, você usaria algumas lâmpadas da sua casa. Dessa forma, quando a noite chegasse, as lâmpadas da sua casa acenderiam automaticamente. E quando o dia chegasse, elas apagariam, sem a necessidade de qualquer intervenção.&lt;/p&gt;
&lt;p&gt;Se você fosse utilizar um dispositivo real qualquer, conectado ao seu hub, então você precisaria de um driver específico que fizesse a comunicação entre o servidor local e o dispositivo. Há uma variedade de drivers já criados para vários dispositivos e plataformas diferentes. Mas se você não encontrar um que atenda sua necessidade, poderá desenvolver o seu próprio. No projeto que eu desenvolvi, eu exemplifiquei a criação de um driver simples. Porém dependendo da sua necessidade, um pouco de conhecimento de eletrônica poderá ser necessário. Algo que eu não sei, e não tenho como ensinar.&lt;/p&gt;
&lt;p&gt;No projeto, além da funcionalidade básica de controle de luminosidade, eu desenvolvi um driver que pudesse controlar o player de mídia do meu computador (o &lt;a href=&quot;http://banshee.fm/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Banshee&lt;/a&gt;). Infelizmente, devido a forma como eu desenvolvi o driver, essa última parte irá funcionar apenas em sistemas operacionais Linux. E que tenham o Banshee instalado… é claro!&lt;/p&gt;
&lt;p&gt;O driver permite pausar a reprodução e voltar a reproduzir a faixa atual. Além de permitir pular para a próxima faixa ou voltar a anterior.&lt;/p&gt;
&lt;p&gt;Imaginando o contexto de Internet das Coisas, podemos imaginar várias aplicações. A minha localização poderia ser monitorada pelo GPS do meu celular, por exemplo. E quando eu estivesse voltando do trabalho, ao chegar próximo de casa, uma música poderia começar a tocar automaticamente em casa. E da mesma forma, parasse quando eu estivesse saindo.&lt;/p&gt;
&lt;h2 id=&quot;Execucao-do-projeto&quot;&gt;&lt;a href=&quot;#Execucao-do-projeto&quot; class=&quot;headerlink&quot; title=&quot;Execução do projeto&quot;&gt;&lt;/a&gt;Execução do projeto&lt;/h2&gt;&lt;p&gt;Todo o &lt;a href=&quot;https://github.com/possatti/sample-zettajs-server/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;código da aplicação&lt;/a&gt; está hospedado no github. E também o &lt;a href=&quot;https://github.com/possatti/zetta-banshee-driver&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;driver para o Banshee&lt;/a&gt;. Para executar o projeto, entre com os comandos abaixo na sua linha de comando. Você precisará instalar no seu computador o &lt;a href=&quot;https://nodejs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Node&lt;/a&gt; e o &lt;a href=&quot;https://www.npmjs.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NPM&lt;/a&gt; (que geralmente já vem com o Node).&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Clone o projeto&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git &lt;span class=&quot;built_in&quot;&gt;clone&lt;/span&gt; https://github.com/possatti/sample-zettajs-server.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Entre no diretório baixado&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; sample-zettajs-server&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Instale as dependências necessárias (inclusive o driver&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# para o banshee)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ npm install&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Inicie o servidor:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ npm start&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Se você não tiver o git instalado em seu computador. Não há problema. Você pode baixar o &lt;a href=&quot;https://github.com/possatti/sample-zettajs-server/archive/v0.1.zip&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;projeto no github&lt;/a&gt; e continuar com &lt;code&gt;npm install&lt;/code&gt; e &lt;code&gt;npm start&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Com isso, o servidor irá iniciar em localhost, na porta 1337, por padrão. E você, de imediato, irá notar, no log da linha de comando, que a LED está acendendo e apagando toda hora. Isso está correto, a célula fotovoltaica está ocasionando esse comportamento.&lt;/p&gt;
&lt;p&gt;Para visualizar tudo o que está acontecendo, eu recomendo o uso do Zetta Browser. Para abrir o Zetta Browser apontando para o seu servidor local (127.0.0.1:1337), entre com o seguinte endereço no seu navegador:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://browser.zettajs.io/#/overview?url=http://127.0.0.1:1337&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://browser.zettajs.io/#/overview?url=http://127.0.0.1:1337&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Mas lembre que isso que você está visualizando é tudo local, apenas. Para realmente ser capaz de acessar este hub através da internet, o servidor local precisa se conectar a um servidor na nuvem. Coisa que esse projeto já está configurado para fazer. Ao ter iniciado o servidor local, ele automaticamente já se conectou ao servidor em hello-zetta.herokuapp.com (isto está configurado no código do projeto). Este servidor do &lt;a href=&quot;https://heroku.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Heroku&lt;/a&gt; é disponibilizado pela equipe desenvolvedora do Zetta, para que iniciantes possam usá-lo. Então qualquer um pode criar sua aplicação e se conectar a ele.&lt;/p&gt;
&lt;p&gt;Para acessar a API do servidor local através da internet, use o Zetta Browser apontando para o servidor do Heroku:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://browser.zettajs.io/#/overview?url=http://hello-zetta.herokuapp.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://browser.zettajs.io/#/overview?url=http://hello-zetta.herokuapp.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Com essa URL, você poderá usar o seu celular, por exemplo, para visualizar a LED e a photocell. Além de poder interagir com o Banshee, se você o tiver instalado.&lt;/p&gt;
&lt;p&gt;Mas, por favor, tenha em mente, que como esta é apenas uma aplicação de demonstração, nenhuma etapa de autenticação é feita. Isto quer dizer que qualquer pessoa em qualquer parte do mundo pode acessar a API que o seu servidor local está provendo. Apesar de que isso não é tão alarmante, pois as únicas coisas que eles podem fazer é controlar a mock LED e o Banshee no seu computador.&lt;/p&gt;
&lt;h2 id=&quot;E-agora&quot;&gt;&lt;a href=&quot;#E-agora&quot; class=&quot;headerlink&quot; title=&quot;E agora?&quot;&gt;&lt;/a&gt;E agora?&lt;/h2&gt;&lt;p&gt;Para aprender mais, você pode continuar interagindo com o servidor, e investigar o código, para ver como o projeto funciona. Conhecimentos de NodeJS e JavaScript com certeza irão lhe ajudar. Para aprender mais sobre o Zetta, um bom ponto de partida é o seu próprio &lt;a href=&quot;http://www.zettajs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;site&lt;/a&gt;, apesar de que, como eu disse, a documentação do projeto falha em alguns pontos.&lt;/p&gt;
&lt;p&gt;E se estiver interessado, você pode tentar construir sua própria aplicação, segundo uma necessidade ou um desejo que você tem. Comesse com algo simples e vá aperfeiçoando a medida que desejar.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      Introdução a internet das coisas, e exemplo de aplicação utilizando o Zetta.
    
    </summary>
    
    
      <category term="javascript" scheme="http://possatti.com.br/tags/javascript/"/>
    
      <category term="IoT" scheme="http://possatti.com.br/tags/IoT/"/>
    
  </entry>
  
  <entry>
    <title>Git Pro Tip: Diretórios vazios</title>
    <link href="http://possatti.com.br/git-pro-tip-diretorios-vazios/"/>
    <id>http://possatti.com.br/git-pro-tip-diretorios-vazios/</id>
    <published>2015-03-26T00:05:29.000Z</published>
    <updated>2016-06-24T22:25:13.011Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;/images/git-logo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Nesse post vou falar sobre algo que me aborrecia quando comecei a usar o git. E que pode trazer dificuldades para outros que estejam iniciando com o git. Falarei sobre o fato de que ele não registra diretórios vazios no repositório.&lt;/p&gt;
&lt;h2 id=&quot;O-problema&quot;&gt;&lt;a href=&quot;#O-problema&quot; class=&quot;headerlink&quot; title=&quot;O problema&quot;&gt;&lt;/a&gt;O problema&lt;/h2&gt;&lt;p&gt;Vamos supor a seguinte situação. Você tem um repositório do git, e acabou de criar um diretório vazio dentro dele. E ao tentar gravar suas mudanças, o git simplesmente não detecta que você criou um novo diretório. Como no exemplo:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Cria um diretório vazio&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ mkdir novo_dir&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Revela o que há no diretório atual&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ ls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;novo_dir&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Verifica o status do repositório&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git status&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;On branch master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Initial commit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nothing to commit (create/copy files and use &lt;span class=&quot;string&quot;&gt;&quot;git add&quot;&lt;/span&gt; to track)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Como podem ver, no exemplo, o diretório vazio foi criado. Mas quando usamos o comando &lt;code&gt;git status&lt;/code&gt;, ele simplesmente não detecta que um novo diretório foi criado.&lt;/p&gt;
&lt;p&gt;A razão disso é simples. O git registra apenas arquivos e não diretórios. Se a minha memória não me falha, no SVN você poderia criar diretórios vazios no repositório. Mas não é o caso do git. Pois tudo o que ele busca, para gravar, são arquivos. Então ele nem mesmo se preocupa com o fato de que você criou um novo diretório. Mas se você colocasse um arquivo ali dentro, aí sim, ele detectaria o arquivo e consequentemente o diretório que o contém.&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Cria um arquivo no novo diretório&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ touch novo_dir/exemplo.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Verifica o status do repositório&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git status&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;On branch master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Initial commit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Untracked files:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  (use &lt;span class=&quot;string&quot;&gt;&quot;git add &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to include &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; what will be committed)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	novo_dir/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nothing added to commit but untracked files present (use &lt;span class=&quot;string&quot;&gt;&quot;git add&quot;&lt;/span&gt; to track)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Vejam que neste último comando ele detectou o diretório, mas somente por causa do arquivo. O que ele irá gravar, na realidade, é o arquivo. E uma das informações relevantes para gravar o arquivo é onde ele está.&lt;/p&gt;
&lt;h2 id=&quot;Porque-isso-me-incomodaria&quot;&gt;&lt;a href=&quot;#Porque-isso-me-incomodaria&quot; class=&quot;headerlink&quot; title=&quot;Porque isso me incomodaria?&quot;&gt;&lt;/a&gt;Porque isso me incomodaria?&lt;/h2&gt;&lt;p&gt;Alguns podem estranhar, e se perguntar: “Mas e daí? O diretório está vazio mesmo!”. Hoje eu concordo com isso. Mas no começo isso me atrapalhava um pouco, quando eu estava começando a usar o git.&lt;/p&gt;
&lt;p&gt;Como, por exemplo, quando eu estava iniciando um novo projeto e usava uma ferramenta para gerar o esqueleto do meu projeto. Assim, a ferramenta criava uma porção de diretórios onde eu deveria colocar meus arquivos. Mas se eu ainda não tivesse desenvolvido nada ainda, eu teria que deixá-los vazio por algum tempo.&lt;/p&gt;
&lt;p&gt;Isso costumava acontecer comigo quando eu criava um novo projeto do &lt;a href=&quot;https://maven.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;maven&lt;/a&gt; pelo eclipse. O eclipse criava várias pastas vazias, segundo a estrutura de um projeto padrão do maven. E essa estrutura era importante, porque ditava a forma como eu deveria organizar meu projeto. Se eu colocasse um teste no diretório errado, por exemplo, o maven não iria incorporá-lo a build. E por esse motivo, as coisas precisavam estar em seu devido lugar.&lt;/p&gt;
&lt;p&gt;E quando eu tentava gravar as alterações no repositório, o git simplesmente não detectava as novas pastas que haviam sido criadas, apenas os arquivos, como o &lt;code&gt;pom.xml&lt;/code&gt;. Então se eu fosse usar um outro computador, e tivesse que clonar o projeto, ele não viria com a estrutura de pastas que eu precisava. Então eu teria que resgatar tudo da minha memória, ou gastar algum tempo procurando na internet como a estrutura deveria ser.&lt;/p&gt;
&lt;h2 id=&quot;Solucao&quot;&gt;&lt;a href=&quot;#Solucao&quot; class=&quot;headerlink&quot; title=&quot;Solução&quot;&gt;&lt;/a&gt;Solução&lt;/h2&gt;&lt;p&gt;A verdade é que não existe uma solução elegante para isso. É uma característica do git que você deve se acostumar. E com o tempo, essa característica realmente passa a fazer sentido. Afinal de contas, para que gravar um diretório vazio? … Ele está vazio! Então não estamos perdendo nada.&lt;/p&gt;
&lt;p&gt;Mas como eu expliquei, em algumas situações você pode querer subir um diretório vazio intencionalmente. Se esse for o seu caso, há algumas alternativas que podemos recorrer. Há uma &lt;a href=&quot;http://stackoverflow.com/questions/115983/how-can-i-add-an-empty-directory-to-a-git-repository&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;questão no Stack Overflow&lt;/a&gt; que tem excelentes sugestões de como fazer isso. E eu vou descrever aqui duas delas que considero mais importantes.&lt;/p&gt;
&lt;p&gt;Uma das possíveis soluções, é que você crie um arquivo vazio dentro da pasta, chamado &lt;code&gt;deletar-depois&lt;/code&gt;, &lt;code&gt;placeholder&lt;/code&gt;, ou qualquer coisa do gênero. O importante é que fique claro para você, e para sua equipe, que esse arquivo deve ser deletado assim que o diretório for preenchido com algum conteúdo importante.&lt;/p&gt;
&lt;p&gt;Outra alternativa é para o caso de você querer &lt;strong&gt;forçar&lt;/strong&gt; com que o diretório esteja &lt;strong&gt;sempre&lt;/strong&gt; vazio (sabe se lá, porque você iria querer isso xD ). Para esta situação, você pode criar um &lt;a href=&quot;http://git-scm.com/docs/gitignore&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;.gitignore&lt;/code&gt;&lt;/a&gt; dentro da pasta, com o seguinte conteúdo:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# Ignora tudo neste diretório&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Exceto este arquivo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;!.gitignore&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Nessa última alternativa, ninguém nunca irá conseguir gravar um arquivo nessa pasta! A não ser que o &lt;code&gt;.gitignore&lt;/code&gt; seja apagado, posteriormente. Isso pois o git irá ignorar todos os arquivos ali dentro, com exceção do &lt;code&gt;.gitignore&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Dada essas duas soluções, eu encerro aqui. Espero que essa dica seja útil. E se tiverem dúvidas, ou quiserem compartilhar alguma experiência própria, podem escrever aqui nos comentários.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      O git não grava pastas vazias em seus repositórios. Entenda porquê, e como contornar o problema.
    
    </summary>
    
    
      <category term="git" scheme="http://possatti.com.br/tags/git/"/>
    
      <category term="protip" scheme="http://possatti.com.br/tags/protip/"/>
    
  </entry>
  
  <entry>
    <title>Jekyll</title>
    <link href="http://possatti.com.br/jekyll/"/>
    <id>http://possatti.com.br/jekyll/</id>
    <published>2014-08-22T10:27:29.000Z</published>
    <updated>2015-03-25T07:56:29.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;/images/jekyll-logo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Nesse primeiro post eu resolvi escrever sobre a ferramenta (Jekyll) que eu usei para criar o meu primeiro blog, e como ela pode ser útil para vários propósitos.&lt;/p&gt;
&lt;h3 id=&quot;O-que-e-o-Jekyll&quot;&gt;&lt;a href=&quot;#O-que-e-o-Jekyll&quot; class=&quot;headerlink&quot; title=&quot;O que é o Jekyll?&quot;&gt;&lt;/a&gt;O que é o Jekyll?&lt;/h3&gt;&lt;p&gt;O &lt;a href=&quot;http://jekyllrb.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jekyll&lt;/a&gt; é um gerador de websites estáticos. Em poucas palavras, o que ele faz é converter um monte de html, css, javascript, markdown, etc em um website estático. Para usa-lo, você define templates para exibir diferentes tipos de publicações, e define o conteúdo separadamente.&lt;/p&gt;
&lt;p&gt;Já que você irá definir a parte bruta através de HTML, CSS e JavaScript, isso te permite ter controle total sobre o estilo do website. Ao mesmo tempo que te permite publicar todo o tipo de conteúdo que você definir.&lt;/p&gt;
&lt;p&gt;Você ganha praticidade quando resolve esquematizar o projeto, dividindo-o em templates e conteúdo. Por exemplo, você pode definir um template para posts de um blog, e define o conteúdo dos posts usando uma linguagem mais simples como &lt;a href=&quot;http://en.wikipedia.org/wiki/Markdown&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;markdown&lt;/a&gt; ou &lt;a href=&quot;http://en.wikipedia.org/wiki/Textile_%28markup_language%29&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;textile&lt;/a&gt; (markdown é o mais usado). Assim, o Jekyll irá se responsabilizar por processar esse conteúdo e enquadra-lo na definição do seu template de posts. Com isso, o resultado final é uma página html completa com o seu conteúdo. Você pode inclusive ter mais de uma definição de template para posts, e em cada post especificar qual template você deseja usar.&lt;/p&gt;
&lt;p&gt;O foco principal do Jekyll está na criação de blogs, mas ele também pode ser usado para projetos mais ambiciosos como por exemplo &lt;a href=&quot;http://www.developmentseed.org/blog/new-healthcare-gov-is-open-and-cms-free/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;o projeto que o grupo Development Seed fez&lt;/a&gt; para criar o portal &lt;a href=&quot;https://www.healthcare.gov/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HealthCare.gov&lt;/a&gt; para o governo norte americano.&lt;/p&gt;
&lt;p&gt;Ferramentas como essa parecem estar ganhado uma popularidade cada vez maior, como alternativas a CMSs (Content Management System), como o &lt;a href=&quot;http://wordpress.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Wordpress&lt;/a&gt; e o &lt;a href=&quot;https://www.drupal.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Drupal&lt;/a&gt;. Pois elimina elementos custosos do desenvolvimento e da manutenção, ao mesmo tempo que te permite um maior controle sobre a estrutura do website. Como exemplo, em um website estático você não precisa se preocupar com um banco de dados. Assim você elimina o custo de ter um, e também de ter pessoas que saibam usá-lo.&lt;/p&gt;
&lt;p&gt;Porém, com isso você pode acabar perdendo alguma funcionalidade dinâmica de um CMS, que a princípio necessite de uma aplicação do lado do servidor. Mas você pode facilmente compensar isso usando APIs de terceiros para compor o seu website. Uma funcionalidade comum de um CMS é a gestão de comentários nas páginas. Mas como você poderia alcançar o mesmo efeito em um site totalmente estático? Você pode usar uma API como a do &lt;a href=&quot;https://disqus.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Disqus&lt;/a&gt;, que vem ganhando bastante popularidade recentemente, ou a do &lt;a href=&quot;https://developers.facebook.com/docs/plugins/comments&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Facebook&lt;/a&gt;. Assim, no final das contas, o que você tem é um pequeno código HTML-JavaScript que você joga em seu template, e assim todas as páginas ganham uma seção de comentários. Uhuul!&lt;/p&gt;
&lt;p&gt;Mas fazer a escolha entre utilizar um CMS ou um gerador de sites estáticos é uma decisão delicada, e que deve ser pensada com cuidado, tendo em vista o objetivo final do projeto.&lt;/p&gt;
&lt;h3 id=&quot;Personalizacao-do-projeto&quot;&gt;&lt;a href=&quot;#Personalizacao-do-projeto&quot; class=&quot;headerlink&quot; title=&quot;Personalização do projeto&quot;&gt;&lt;/a&gt;Personalização do projeto&lt;/h3&gt;&lt;p&gt;É possível ainda, acrescentar outras ferramentas no ciclo de vida do seu projeto. Deixando o desenvolvimento mais a seu próprio gosto. Por exemplo, você pode combinar pre-processadores (como o &lt;a href=&quot;http://lesscss.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Less&lt;/a&gt; ou &lt;a href=&quot;http://sass-lang.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Sass&lt;/a&gt;) para a sua build.&lt;/p&gt;
&lt;p&gt;E se você não quiser se preocupar com o desenvolvimento bruto do site, você pode simplesmente escolher um tema já pronto, e se preocupar apenas com o conteúdo. Mas isso te limita a usar o que outras pessoas já criaram.&lt;/p&gt;
&lt;p&gt;Existem vários temas para o Jekyll já prontos, a grande maioria deles focada em blogs. Basta escolher um deles, e começar a publicar… como eu fiz ;) . Mas se você tiver os conhecimentos necessários, você pode se aventurar e criar o seu próprio tema, e assim construir tudo completamente personalizado.&lt;/p&gt;
&lt;p&gt;E como eu disse, há vários temas espalhados pela internet (você pode dar uma olhada &lt;a href=&quot;http://jekyllthemes.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;nesse link&lt;/a&gt; para conferir vários deles) feitos por diversas pessoas que resolveram compartilhar seus trabalhos. Há alguns bem simples e outros mais elaborados e de muito bom gosto. Cabe a você escolher.&lt;/p&gt;
&lt;p&gt;Mas já adianto que se você pretende criar algo muito diferente de um blog, você provavelmente terá que criar tudo manualmente. Isso não é problema do Jekyll em si, pois ele suporta a geração de diversos tipos de conteúdo, e é possível customiza-lo para o que for necessário. Mas se o que você quer for muito específico é provável que você não encontrará nada pronto pela internet.&lt;/p&gt;
&lt;p&gt;Se o Jekyll não te atender em algum aspecto você pode experimentar outros geradores de sites estáticos como: &lt;a href=&quot;http://octopress.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Octopress&lt;/a&gt; (usa o Jekyll), &lt;a href=&quot;http://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;, &lt;a href=&quot;http://nanoc.ws/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;nanoc&lt;/a&gt;, entre &lt;a href=&quot;http://staticsitegenerators.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;vários outros&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;Como-usar&quot;&gt;&lt;a href=&quot;#Como-usar&quot; class=&quot;headerlink&quot; title=&quot;Como usar&quot;&gt;&lt;/a&gt;Como usar&lt;/h3&gt;&lt;p&gt;Não adianta chorar, você provavelmente terá que sujar as mãos em algum momento e usar a linha de comando. Mas não é difícil como algumas pessoas pensam. Logo, pare de reclamar, se for o seu caso, e siga em frente. ¬¬&lt;/p&gt;
&lt;p&gt;Para exemplificar o uso do Jekyll, vou descrever aqui como criar e gerenciar um blog simples, sem nada demais. Assim você terá conhecimento de como ele funciona, e poderá, então, escolher se irá personalizar tudo na mão ou pegar um tema já pronto e pular o trabalho duro. De qualquer forma, é útil ter um conhecimento de como ele funciona.&lt;/p&gt;
&lt;p&gt;O primeiro passo de todos é instala-lo na sua máquina. Para isso consulte as &lt;a href=&quot;http://jekyllrb.com/docs/installation/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;intruções de instalação&lt;/a&gt; no site oficial. Lá você encontra instruções detalhadas para a instalação na sua plataforma específica.&lt;/p&gt;
&lt;p&gt;Porém, um método fácil de instala-lo é usando o RubyGem (gerenciador de pacotes da linguagem Ruby), através de um único comando:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Talvez você tenha que usar sudo&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ gem install jekyll&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Após isso, basta um comando para criar um novo projeto:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ jekyll new meu-novo-blog&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Assim o jekyll irá criar um exemplo de um blog bem básico com a estrutura exemplificada abaixo (para servir as páginas em localhost basta executar &lt;code&gt;jekyll serve&lt;/code&gt;).&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; meu-novo-blog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ tree&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── about.md&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── _config.yml&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── css&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;│   └── main.css&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── feed.xml&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── _includes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;│   ├── footer.html&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;│   ├── header.html&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;│   └── head.html&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── index.html&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── _layouts&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;│   ├── default.html&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;│   ├── page.html&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;│   └── post.html&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;└── _posts&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    └── 2014-08-30-welcome-to-jekyll.markdown&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Então, permita-me explicar um pouco sobre essa estrutura. &lt;code&gt;_config.yml&lt;/code&gt; é o arquivo de configuração do seu site, que contém informações como: nome do site, seu e-mail, plugins usados, etc. Esse arquivo utiliza a sintaxe &lt;a href=&quot;http://pt.wikipedia.org/wiki/YAML&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;YAML&lt;/a&gt;. O diretório &lt;code&gt;_includes&lt;/code&gt; contém “pedaços de HTML” que você usará para definir seus layouts (templates). Em &lt;code&gt;_layouts&lt;/code&gt; você deve colocar os seus templates. (Os layouts são páginas quase completas, esperando apenas para receberem conteúdo.) E, finalmente, em &lt;code&gt;_posts&lt;/code&gt; você define seus posts em uma linguagem simples como o markdown, por exemplo.&lt;/p&gt;
&lt;p&gt;Se você investigar os arquivos html que foram gerados (em &lt;code&gt;_includes/&lt;/code&gt; e &lt;code&gt;_layouts/&lt;/code&gt;), verá que neles foi usado uma notação diferente no meio do html (um monte de chaves &lt;code&gt;{}&lt;/code&gt; espalhados). Isso que está sendo usado, são tags &lt;a href=&quot;http://liquidmarkup.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Liquid&lt;/a&gt;. Elas são &lt;a href=&quot;http://jekyllrb.com/docs/templates/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;usadas pelo Jekyll para a definição dos templates&lt;/a&gt;. Você precisará entender como elas funcionam para quando você quiser criar os seus próprios templates. Mas não são necessárias quando você estiver escrevendo seus posts.&lt;/p&gt;
&lt;p&gt;Você pode notar também que quando executamos &lt;code&gt;jekyll new&lt;/code&gt;, ele criou uma página inicial (&lt;code&gt;index.html&lt;/code&gt;) e um &lt;code&gt;about.md&lt;/code&gt; (que quando processado se tornará &lt;code&gt;about.html&lt;/code&gt;). Além disso, ele gerou um exemplo de um post para você em &lt;code&gt;_posts/&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A essa altura você deve querer visualizar o resultado de tudo isso. Então vamos em frente, e depois voltamos para esclarecer mais algumas coisas. Para gerar o website estático é necessário apenas executar o comando &lt;code&gt;jekyll build&lt;/code&gt; e o jekyll irá processar todos os seus arquivos e gerar o resultado no diretório &lt;code&gt;_site&lt;/code&gt;. Isso só já basta para você conseguir o que realmente importa (um website estático), mas vamos fazer um pouco mais do que isso, e vamos executar &lt;code&gt;jekyll serve&lt;/code&gt;. Assim ele irá servir em localhost os arquivos gerados, para que você possa visualizar o site. Então, depois desse último comando, abra o navegador e entre em &lt;code&gt;localhost:4000&lt;/code&gt;, por padrão, e veja o seu mais novo blog! Tcharaaam!&lt;/p&gt;
&lt;p&gt;Repare que é possível executar &lt;code&gt;jekyll serve --watch&lt;/code&gt; para que o Jekyll fique “assistindo” o diretório do projeto. E quando qualquer mudança acontecer (quando você editar um post, por exemplo), ele irá gerar novamente os arquivos necessários. O único arquivo que ele não irá assistir é o &lt;code&gt;_config.yml&lt;/code&gt;. E também repare que não é necessário executar &lt;code&gt;jekyll build&lt;/code&gt; antes de &lt;code&gt;jekyll serve&lt;/code&gt;, pois esse último já executa a build automaticamente.&lt;/p&gt;
&lt;p&gt;Entenda o que o Jekyll fez. Ele construiu o site, em basicamente duas etapas. Primeiramente, ele tomou todos os arquivos que necessitavam de processamento (os arquivos em markdown e textile) e os processou combinando com os layouts e includes necessários,  gerando arquivos de html para cada um deles. Repare que os diretórios de destino dos posts é diferente do comum, o Jekyll usa o nome do post para criar diretórios de destino para eles. Isso da seguinte forma, se você tem um post chamado &lt;code&gt;2014-10-19-exemplo.md&lt;/code&gt; ele será processado e irá parar em &lt;code&gt;_site/2014/10/19/exemplo.html&lt;/code&gt;. Mas fora isso, todos os arquivos vão parar em lugares segundo suas posições relativas ao diretório raiz do projeto (exemplo: &lt;code&gt;/about/index.md&lt;/code&gt; é processado e vai parar em &lt;code&gt;_site/about/index.html&lt;/code&gt;) da forma como você esperaria.&lt;/p&gt;
&lt;p&gt;A segunda etapa da build é mais simples. Ele copia todos os arquivos que não necessitam de processamento, como imagens, css, javascript, etc, para o diretório &lt;code&gt;_site/&lt;/code&gt;. Então, por exemplo, um arquivo &lt;code&gt;/imagens/foto.jpg&lt;/code&gt; vai parar em &lt;code&gt;_site/imagens/foto.jpg&lt;/code&gt;).&lt;/p&gt;
&lt;h3 id=&quot;YAML-Front-Matter&quot;&gt;&lt;a href=&quot;#YAML-Front-Matter&quot; class=&quot;headerlink&quot; title=&quot;YAML Front Matter&quot;&gt;&lt;/a&gt;YAML Front Matter&lt;/h3&gt;&lt;p&gt;Mas que tipo de arquivos são processados pelo Jekyll exatamente? E quais são simplesmente copiados sem processamento? Por definição do Jekyll, somente são processados os arquivos com extenções do markdown ou textile, e os arquivos que tenham um cabeçalho especial, chamado de &lt;a href=&quot;http://jekyllrb.com/docs/frontmatter/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;“YAML Front Matter”&lt;/a&gt;. Quando o Jekyll detectar esse tipo de cabeçalho ele irá processar o arquivo. Um “front matter” deve ser colocada logo no começo do arquivo e se parece com o seguinte:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;layout: post&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;title: &amp;quot;Jekylll&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;modified: 2014-08-22 07:27:29 -0300&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tags: [jekyll]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;comments: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;A sintaxe utilizada para a codificação do “Front Matter” é a &lt;a href=&quot;http://pt.wikipedia.org/wiki/YAML&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;YAML&lt;/a&gt; (assim como o arquivo &lt;code&gt;_config.yml&lt;/code&gt;). E nessa seção você pode definir variaveis que serão utilizadas pelo Jekyll (como &lt;code&gt;layout&lt;/code&gt; e &lt;code&gt;title&lt;/code&gt;). E, até mesmo, variáveis personalizadas, como é o caso do exemplo acima em que a variável &lt;code&gt;comments&lt;/code&gt; é utilizada pelo meu tema atual, para saber quando ele deve incluir uma seção de comentários, ou não, em um post.&lt;/p&gt;
&lt;p&gt;E se você quiser que o arquivo seja processado, mas ele não precisa de nenhuma variável, você ainda assim precisa de incluir o front matter. Mas pode deixa-lo vazio, sem nenhuma variável. Isso pode ser útil quando você quer usar Liquid Tags em arquivos css e javascript, por exemplo.&lt;/p&gt;
&lt;h3 id=&quot;Hospedagem-no-Github-Pages&quot;&gt;&lt;a href=&quot;#Hospedagem-no-Github-Pages&quot; class=&quot;headerlink&quot; title=&quot;Hospedagem no Github Pages&quot;&gt;&lt;/a&gt;Hospedagem no Github Pages&lt;/h3&gt;&lt;p&gt;Ok… mas e depois que você criar o seu website e quiser publicá-lo na internet? Você pode optar por várias possibilidades, inclusive a de usar o seu próprio servidor pessoal. Porém, o que eu considero mais prático, no momento, é utilizar a hospedagem gratuita do &lt;a href=&quot;https://pages.github.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Github Pages&lt;/a&gt;. Para mim, a forma mais simples para publicar seu site, é você criar um repositório na sua conta do GitHub chamado &lt;code&gt;&amp;lt;seu-nome-de-usuario&amp;gt;.github.io&lt;/code&gt; e subir o seu projeto do Jekyll para o novo repositório. O GitHub irá processar o seu projeto do Jekyll e gerar o seu website estático no endereço &lt;code&gt;&amp;lt;seu-nome-de-usuario&amp;gt;.github.io&lt;/code&gt;. Simples assim. Apenas preste atenção na versão do Jekyll que você está usando e a versão que está sendo usada pelo GitHub (confira &lt;a href=&quot;https://pages.github.com/versions/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;aqui&lt;/a&gt;). Mas isso não deve ser um problema.&lt;/p&gt;
&lt;p&gt;Se preferir, você pode construir o site na sua máquina e subir o resultado final para o GitHub Pages. Isso é uma outra possibilidade. Assim, você tem controle de qual versão do Jekyll utilizar, e também usar plugins em sua build (coisa que o github bloqueia para evitar que plugins maliciosos executem). Você pode até usar um domínio personalizado se quiser. Para entender melhor como o GitHub Pages funciona, leia a &lt;a href=&quot;https://pages.github.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;página oficial do Github Pages&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;O-que-fazer-depois&quot;&gt;&lt;a href=&quot;#O-que-fazer-depois&quot; class=&quot;headerlink&quot; title=&quot;O que fazer depois?&quot;&gt;&lt;/a&gt;O que fazer depois?&lt;/h3&gt;&lt;p&gt;Se você não sabe para onde ir agora, e o que fazer para aprender mais, eu te aconselho a brincar com o blog que criamos nesse tutorial. Crie um novo post; dê uma olhada em como funcionam os layouts e includes; futuque as Liquid Tags e veja como elas funcionam; etc.&lt;/p&gt;
&lt;p&gt;Se você ainda tiver dúvidas ou quiser entender melhor as coisas, eu recomendo que você dê uma olhada na &lt;a href=&quot;http://jekyllrb.com/docs/home/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentação do Jekyll&lt;/a&gt; (em inglês). A documentação é boa, e fala sobre vários aspectos da ferramenta. E tudo está escrito de forma clara e concisa.&lt;/p&gt;
&lt;p&gt;É isso aí! Até mais. :)&lt;/p&gt;
</content>
    
    <summary type="html">
    
      Breve introdução ao Jekyll, um gerador de websites estáticos, com foco em blogs.
    
    </summary>
    
    
      <category term="jekyll" scheme="http://possatti.com.br/tags/jekyll/"/>
    
  </entry>
  
</feed>
